syntax = "proto3";

// Module Input
message ModuleInput {
	// Parameters controlling the types of clients that compose the network
	repeated Participant participants = 1;
	
	// Parameters controlling the settings of the network itself
	optional NetworkParams network_params = 2;

	// True by defaults such that in addition to the Ethereum network:
	//  - A transaction spammer is launched to fake transactions sent to the network
	//  - Forkmon will be launched after CL genesis has happened
	//  - a prometheus will be started, coupled with grafana
	// If set to false:
	//  - only Ethereum network (EL and CL nodes) will be launched. Nothing else (no transaction spammer)
	//  - params for the CL nodes will be ignored (e.g. CL node image, CL node extra params)
	// This is a hack - it's not very elegant - but this is a commonly-requested feature
	// The longterm solution is making the module trivial to decompose so we don't need flags like this; we're working
	//  on this at the Kurtosis product level
	optional bool launch_additional_services = 3;

	// If set, the module will block until a finalized epoch has occurred.
	// If `waitForVerifications` is set to true, this extra wait will be skipped.
	optional bool wait_for_finalization = 4;

	// If set to true, the module will block until all verifications have passed
	optional bool wait_for_verifications = 5;

	// If set, after the merge, this will be the maximum number of epochs wait for the verifications to succeed.
	optional uint64 verifications_epoch_limit = 6;

	// The log level that the started clients should log at
	optional GlobalClientLogLevel global_client_log_level = 7;
}

enum GlobalClientLogLevel {
	info = 0;
	error = 1;
	warn = 2;
	debug = 3;
	trace = 4;
}

enum ELClientType {
	geth = 0;
	erigon = 1;
	nethermind = 2;
	besu = 3;
}

enum CLClientType {
	lighthouse = 0;
	teku = 1;
	nimbus = 2;
	prysm = 3;
	loadstar = 4;
}

message BuilderNetworkParams {
	// A list of endpoints to reach block builder relays
	repeated string relay_endpoints = 1;
}

message Participant {
	// The type of EL client that should be started
	optional ELClientType el_client_type = 1;
	// The Docker image that should be used for the EL client; leave blank to use the default
	optional string el_client_image  = 2;
	// The log level string that this participant's EL client should log at
	// If this is emptystring then the global `logLevel` parameter's value will be translated into a string appropriate for the client (e.g. if
	//  global `logLevel` = `info` then Geth would receive `3`, Besu would receive `INFO`, etc.)
	// If this is not emptystring, then this value will override the global `logLevel` setting to allow for fine-grained control
	//  over a specific participant's logging	
	optional string el_client_log_level = 3;
	// Optional extra parameters that will be passed to the EL client
	repeated string el_extra_params = 4;

	// The type of CL client that should be started
	optional CLClientType cl_client_type = 5;
	// The Docker image that should be used for the EL client; leave blank to use the default
	// NOTE: Prysm is different in that it requires two images - a Beacon and a validator
	//  For Prysm and Prysm only, this field should contain a comma-separated string of "beacon_image,validator_image"	
	optional string cl_client_image  = 6;
	// The log level string that this participant's CL client should log at
	// If this is emptystring then the global `logLevel` parameter's value will be translated into a string appropriate for the client (e.g. if
	//  global `logLevel` = `info` then Nimbus would receive `INFO`, Prysm would receive `info`, etc.)
	// If this is not emptystring, then this value will override the global `logLevel` setting to allow for fine-grained control
	//  over a specific participant's logging	
	optional string cl_client_log_level = 7;
	
	// Extra parameters that will be passed to the Beacon container (if a separate one exists), or to the combined node if
	// the Beacon and validator are combined
	repeated string beacon_extra_params = 8;

	// Extra parameters that will be passed to the validator container (if a separate one exists), or to the combined node if
	// the Beacon and validator are combined
	repeated string validator_extra_params = 9;

	optional BuilderNetworkParams builder_network_params = 10;
}

message NetworkParams {
	// The network ID of the Eth1 network
	optional string network_id = 1;
	// The address of the staking contract address on the Eth1 chain
	optional string deposit_contract_address = 2;
	// Number of seconds per slot on the Beacon chain
	optional uint32 seconds_per_slot = 3;
	// Number of slots in an epoch on the Beacon chain
	optional uint32 slots_per_epoch = 4;
	// The number of validator keys that each CL validator node should get
	optional uint32 num_validators_per_keynode = 5;
	// This menmonic will a) be used to create keystores for all the types of validators that we have and b) be used to generate a CL genesis.ssz that has the children
	//  validator keys already preregistered as validators	
	optional string preregistered_validator_keys_mnemonic = 6;
}


// Module Output
message ModuleOutput {
	GrafanaInfo grafana_info = 1;
}

message GrafanaInfo {
	string dashboard_path = 1;
	string user = 2;
	string password = 3;
}

